On Site Round 4 (Googliness)
Will suggest to go through this https://www.youtube.com/@jeffhsipepi

GOOGELYNESS: https://leetcode.com/discuss/interview-question/4859465/Google-or-Software-Engineer-or-Bengaluru-or-L3-or-SELECTED
https://leetcode.com/discuss/interview-experience/5021795/Google-L3-Bangalore-(Offer)

https://leetcode.com/discuss/interview-experience/4999647/Google-or-L4-or-Bangalore-or-Jan-2024-Offer


 22 L Fixed + 4 L JB + Stocks (Didn't want to downgrade to L3 level, hence didn't accept the offer)
 base is around 22-24
 stocks is around 10L 
 joining bonus : 4L



UPD: Just got the mail for next round of interviews. (alwasys use google-candidate-feedback in case of delay from any side, thank me later)

google-candidate-support@googleDotcom



https://leetcode.com/discuss/interview-question/3899826/Offer-Google-India-or-SWE-3-L4

important: https://leetcode.com/discuss/interview-question/4859465/Google-or-Software-Engineer-or-Bengaluru-or-L3-or-SELECTED

https://leetcode.com/discuss/interview-question/4849502/Google-or-Question
https://leetcode.com/discuss/interview-question/4831503/Google-or-Questions






Google [Recruiter reached out based on past engagement; this was my 3rd interview loop with Google]

Phone Screen [DSA]: Implement rate limiter (HashMap, LC Easy to Medium)
Round 1 [DSA]: Implement a novel data structure for insert, search, delete operations with certain criteria. (Queue, LC Medium)
Round 2 [DSA]: Discrete mathematics (Arithmetic Progression) + Array [LC Medium to Hard]
Round 3 [DSA]: Simple Disjoint Set based problem [LC Medium, Hard if you don't know Disjoint Set optimisations]
Round 4 [Googleyness]: Questions on scenarios prevalent in US or other countries but not so common in India (Hard)




Link: https://leetcode.com/discuss/interview-question/4831503/Google-or-Questions

Hi Everyone,

Recently I have gone through onsite rounds, I have compiled few repeated questions asked by Google.
I hope it will be helpful for others who are preparing

Q1-

Problem: A circle is define by x-axis position, y-axis position, and a
radius. A circle group is a collection of circles that overlap. Given a
list of circles, figure out if they belong to a single circle group









Q2-

For a rooted tree with any arbitary number of children for each node,
not necessarily n-ary tree.
Remove all the leaf nodes, and store them in a list, this would create
new leaf nodes. Repeat untill all the nodes are removed
Conditions : Freshly created leaf nodes(node whose children are removed)
should not be removed just after its children are removed, unless
there's no other option for us, then we can remove it









Q3-

Design a search data structure to store and display recent searches. If
a user just clicks the search bar without typing anything, it should
return the N most recent searches. Given a search string it should save
the search and also return the N most recent searches




Q4-
find a path that has the minimum cost



Given map {X=>123, Y=456}
Input: %X%_%Y%
Output: 123_456
Given map {USER=>admin, HOME=>/%USER%/home} Input: I am %USER% My home is %HOME% Output: I am admin My home is /admin/home
USER= bob
HOME= /home/%USER% should be substituted as : /home/bob ex2:
home/ %USER% -> /home/bob
Hello %USER% -> Hello bob!
ex3:
The user %USER% is at 50%% -> The user bob is at 50%






Q5-

You are given a list of user sessions where each user session has start and end times both inclusive. Now, given a value N, find the count of all users at each point in time from [0,N) i.e include 0 but exclude N. Example:
Input:
[(0,3), (1,4) ] N=7
Output:
0->1
1->2
2->2
3->2
4->1




Q6-

A number of students are taking exams in a room. Students sitting adjacent to each other and taking the same exam can cheat. Arrange the students so that cheating opportunities are minimized. I was free to choose input format.
I chose the input to be a list of length n, denoting n students. The element at index i would indicate the exam student i is taking.
For example, [1,2,3,1,2,2]
Student 0 is taking exam 1
Student 1 is taking exam 2
Student 2 is taking exam 3
Student 3 is taking exam 1
Student 4 is taking exam 2
Student 5 is taking exam 2
Output would be a list with the students re-arranged. An acceptable output for the above case would be [1,2,3,2,1,2].




Q7-

Replace files with directories if all files in directory are
specified
Example input & output:
allFiles = [
"a/b/c/d.txt",
"a/b/c/e.txt",
"a/b/b.txt",
"a/b/e.txt",
"b/c/d.txt"
]
subsetFiles = [
"a/b/c/d.txt",
"a/b/c/e.txt",
"a/b/b.txt",
"b/c/d.txt"
]
output=[
"a/b/c",
"a/b/b.txt",
"b"
]






Q8-

You have a stream of rpc requests coming in. Each log is of the
form {id, timestamp, type(start/end)}. Given a timeout T, you need to figure out at the earliest possible time if a request
has timed out.
Eg :
id - time - type
0 - 0 - Start
1 - 1 - Start
0 - 2 - End
2 - 6 - Start
1 - 7 - End
Timeout = 3
Ans : {1, 6} ( figured out id 1 had timed out at time 6 )







Q9-

Give a list of string, where every string in the list is of size 5. Return the list of 5 string such that all the characters in each of the strings are unique
i.e if we combine all the strings(not nnecessary) we will have 25 unique characters)
eg
Input explanation
List of string with length of 5 each
intput = ["abcde", "fghij", "klmno", "pqrst", "uvwxy", "zabcd", "apple", "zebra", "ocean", "quick", "world", "jumps", "foxes", "liver"]





Q10-

sort all odd elements and leave even elements as it is at their original position | [ x-> 2*x+1 -> sort() -> (x-1)/2 ; ]








Q11-

You work as a consultant and have clients in cityA and cityB. On a given day,
say i, you can either
work in cityA and make Ai dollars or you can work in cityB and make Bi dollars. You can also spend
the day traveling between cityA and cityB in which case your earnings that day are 0.
Given Al,A2, ....An and B1, B2,....., Bn, return a schedule S of N days which maximizes your earnings,
where S is a string of length N, and Si = A/B/T where A means work in cityA, B means work in cityB
T means travel on day i. You can start either in cityA or cityB. Example1: A = [23, 4,5 ,101] B = [21,1,10, 100] The optimal schedule S here would be ->"ATBB"
Example 2:
A[25,10,15,10,70] B = [5,5,50,5,30] The optimal schedule S here would be-> "ATBTA"





Q12-

Give the count of managers who has salary less than average salary of direct and indirect employees
Example:
A->B, A->C, A->D, B->E
Salaries
A = 50000
B = 20000
C = 10000
D = 10000
E = 25000
Answer: 1







Q13-

Explanation: A is the manager of direct employees B, C, D and indirect employee E so avg. is 16,250 and B = 20000 < E = 25000 so answer is B





Q14-

There is a robot at location (0, 0) of a 10x10 grid of tiles. Each tile can be one of 8 different colors: (0, 1, ... 7). There is a star at a known location (marked with the color -1) on the grid. You can program the robot by giving it a lookup table of color to direction. The robot will sense the color of the tile it is currently on, and move in the direction (up, down, left, or right) specified by the lookup table you provided. Output a lookup table that guides the robot to the star, if such a table is possible.
Small example grid: [[(0), 1, 0, 0], [3, 2,-1, 3], [0, 0, 0, 2], [0, 0, 0, 4]]







Q15-

There is a stream of integers. Every time you see a new element in the stream, return the mean value of the last N elements, excluding the largest K elements.
Example:
N=5
K=2
elements so far = [20, 2, -2, 0, 10, 1, 5, -2, 0]
last N elements: [10, 1, 5, -2, 0] largest K elements: [10, 5]
result = (1+(-2)+0)/3 = -0.3333333







Q16-

Find the length of longest increasing subsequence such that the difference between consecutive elements in LIS is an increasing sequence
Example :
nums -> 1 2 3 4 5 6 ans -> 3
Explanation : the best LIS can be gotten if we take 1 , 2 , 4 ( in this way )









Q17-


Given a sparse bit array A of size M stored in a database. The database provides an API query(L,R) which returns 1 if there is at least one bit equal to one in A[L..R] and 0 otherwise.

You want to find all the 1 bits in a reasonable number of queries. E.g. for array 01100000001, positions of 1 bits are {1, 2, 10}.

Return the array of all the positions of 1's.

T.C -> It should not be linear.
S.C -> It should be constant.

You should not use recursion or extra function. (this part was the followup to the recursive and queue approach).


































































Hi Everyone,

I see lots of people are going through the following questions and so i thought may be it will be helpful for those who are looking answers for the same. It might not be optimized for all questions, but it will surely help you to get started !! Thank me later if you get one from below in your round. Good luck to all of you.

https://leetcode.com/discuss/interview-question/4831503/google-questions/2291792






Q1-

Problem: A circle is define by x-axis position, y-axis position, and a
radius. A circle group is a collection of circles that overlap. Given a
list of circles, figure out if they belong to a single circle group

Q-1


class Circle {
    int x, y, radius;

    public Circle(int x, int y, int radius) {
        super();
        this.x = x;
        this.y = y;
        this.radius = radius;
    }

    public boolean isOverLapping(Circle cir) {
        int radius_square = (cir.radius + this.radius) * (cir.radius + this.radius);
        int distance = (this.x - cir.x) * (this.x - cir.x) - (this.y - cir.y) * (this.y - cir.y);
        return distance <= radius_square;
    }
}
public class CirclesBelongToSameComponenet {

    public boolean circleOfSameComponet(List<Circle> list) {

        int n = list.size();
        int parent[] = new int[n];
        Arrays.fill(parent, -1);

        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                if (i != j && list.get(i).isOverLapping(list.get(j))) {
                    int iParent = findParent(i, parent);
                    int jParent = findParent(j, parent);
                    if (iParent != jParent) {
                        parent[iParent] = jParent;
                    }
                }
            }
        }
        int count = 0;
        for (int i = 0; i < n; i++) {
            if (parent[i] == -1) {
                count++;
            }
            if (count > 1)
                return false;
        }
        return true;

    }

    private int findParent(int i, int[] parent) {

        if (parent[i] == -1)
            return i;
        return findParent(parent[i], parent);
    }

    public static void main(String[] args) {
        List<Circle> circles = new ArrayList<>();
        circles.add(new Circle(1, 2, 4));
        circles.add(new Circle(3, 7, 5));
        circles.add(new Circle(2, 2, 4));
        CirclesBelongToSameComponenet c = new CirclesBelongToSameComponenet();
        boolean result = c.circleOfSameComponet(circles);
        System.out.println(result);
    }
}





--------------------------------------------------------------------------


For a rooted tree with any arbitary number of children for each node,
not necessarily n-ary tree.
Remove all the leaf nodes, and store them in a list, this would create
new leaf nodes. Repeat untill all the nodes are removed
Conditions : Freshly created leaf nodes(node whose children are removed)
should not be removed just after its children are removed, unless
there's no other option for us, then we can remove it






---
Q-2
//So here we are going from child to parent level
//so we will follow post traversal
//so first we will go to the top left most then right and then root
//+1 we have added here for level

class Solution {
    public List<List<Integer>> findLeaves(TreeNode root) {
        List<List<Integer>> res = new LinkedList<>();
        dfs(root, res);
        return res;
    }

    private int dfs(TreeNode root, List<List<Integer>> res){
        if (root == null)
            return -1;
        int level = Math.max(dfs(root.left, res), dfs(root.right, res)) + 1;
        if (res.size() <= level)
            res.add(new LinkedList<>());
        res.get(level).add(root.val);
        return level;
    }
}

//TC : O(N) SC : O(N) // N -- total number ot nodes in BT
--





------------------------------------------------------------------------------------

Design a search data structure to store and display recent searches. If
a user just clicks the search bar without typing anything, it should
return the N most recent searches. Given a search string it should save
the search and also return the N most recent searches



Q-3
class Node{
    String val;
    Node prev;
    Node next;

    public Node(String val){
        this.val = val;
    }
}

// S: O(unique strings)
class SearchDS{
    int N;
    Map<String, Node> map;
    Node left;
    Node right;

    public SearchDS(int num){
        this.N = num;
        map = new HashMap<>();
        left.next = right;
        right.next = left;
    }

    //R : O(1)
    public void addSearch(String s){
        if(!map.containsKey(s)){
            map.put(s, new Node(s));
        }else{
            remove(map.get(s));
        }

        insert(map.get(s));
    }

    // R: O(N)
    public List<String> getRecentSearches(){
        List<String> res = new ArrayList<>();
        Node curr = this.right;
        int iter = this.N - 1;

        while(iter >= 0 && curr != left){
            res.add(curr.val);
            iter--;
            curr = curr.prev;
        }

        return res;
    }

    //remove node from DLL
    public void remove(Node n){
        Node prv = n.prev;
        Node nxt = n.next;

        prv.next = nxt;
        nxt.prev = prv;
    }

    //add Node at right
    public void insert(Node n){
        Node prv = right.prev;
        Node nxt = right;

        prv.next = n;
        nxt.prev = n;
        n.prev = prv;
        n.next = nxt;
    }
}

---



-------------------------------------------------------------------------




Q4-
find a path that has the minimum cost


    vector< vector< int > >A(3, vector<int>(3,0));

    for( auto &x : A )
    for( auto &i : x )
        cin>>i ;

    int M = A.size();
    int N = A[0].size();

    auto dp_max = A ;
    auto dp_min = A ;

    for( int i = 1 ; i < M ; i++ )
    {
        dp_max[i][0] = max( dp_max[i][0] , dp_max[i-1][0] ) ;
        dp_min[i][0] = min( dp_min[i][0] , dp_min[i-1][0] );
    }

    for( int j = 1 ; j < N ; j++ )
    {
        dp_max[0][j] = max( dp_max[0][j] , dp_max[0][j-1] );
        dp_min[0][j] = min( dp_max[0][j] , dp_min[0][j-1] );
    }



    for( int i = 1 ; i < M ; i++ )
    for( int j = 1 ; j < N ; j++ )
    {
        int mx = dp_max[i][j];
        int mn = dp_min[i][j];

        mx = max(
                mx , 
                min( dp_max[i][j-1] , dp_max[i-1][j] )
            );

        mn = min(
                mn , 
                max( dp_min[i][j-1] , dp_min[i-1][j] )
            );

        dp_max[i][j] = mx ;
        dp_min[i][j] = mn ;
    }

    cout<<dp_max[M-1][N-1] - dp_min[M-1][N-1]<<endl;
--










---------------------------------------------------------------


Q5-

Given map {X=>123, Y=456}
Input: %X%_%Y%
Output: 123_456
Given map {USER=>admin, HOME=>/%USER%/home} Input: I am %USER% My home is %HOME% Output: I am admin My home is /admin/home
USER= bob
HOME= /home/%USER% should be substituted as : /home/bob ex2:
home/ %USER% -> /home/bob
Hello %USER% -> Hello bob!
ex3:
The user %USER% is at 50%% -> The user bob is at 50%


Q-5
package org.example;

import java.util.HashMap;
import java.util.HashSet;
import java.util.LinkedList;
import java.util.Queue;

//Build the relationship between every key and words. (Build graph)
//Find those keys that are not depend on anyone to construct, and put it into a queue
//Build our own dictionary {key, correct replacement}
//Iterate though our input string, and reconstruct the output.
public class StringSubstitutor {
    public static HashSet<String> getWord(String words) {
        HashSet<String> set = new HashSet<>();
        int i = 0;
        while (i < words.length()) {
            StringBuilder temp = new StringBuilder();
            if (words.charAt(i) == '%') {
                temp.append(words.charAt(++i));
                while (i < words.length() && words.charAt(i) != '%') {
                    temp.append(words.charAt(++i));
                }
                temp.deleteCharAt(temp.length() - 1);
                set.add(temp.toString());
            }
            i++;
        }
        return set;
    }

    public static String replace(String w, HashMap<String, String> dict) {
        StringBuilder temp = new StringBuilder();
        int i = 0;
        while (i < w.length()) {
            if (w.charAt(i) == '%') {
                int l = ++i;
                while (i < w.length() && w.charAt(i) != '%') {
                    i++;
                }
                String newWord = dict.get(w.substring(l, i));
                temp.append(newWord);
                i++;
            } else {
                temp.append(w.charAt(i));
                i++;
            }
        }
        return temp.toString();
    }

    public static HashMap<String, String> replaceHelp(HashMap<String, String> map) {
        HashMap<String, HashSet<String>> graph = new HashMap<>();
        HashMap<String, Integer> indegree = new HashMap<>();
        HashMap<String, String> dict = new HashMap<>();
        Queue<String> queue = new LinkedList<>();

        for (String key : map.keySet()) {
            String words = map.get(key);
            HashSet<String> set = getWord(words);
            if (set.isEmpty()) {
                indegree.put(key, 0);
                dict.put(key, words);
                queue.add(key);
            } else {
                for (String iter : set) {
                    indegree.put(key, indegree.getOrDefault(key, 0) + 1);
                    graph.computeIfAbsent(iter, k -> new HashSet<>()).add(key);
                }
            }
        }
        while (!queue.isEmpty()) {
            String curKey = queue.poll();
            String w = map.get(curKey);

            if (!dict.containsKey(curKey)) {
                dict.put(curKey, replace(w, dict));
            }
            for (String nextKey : graph.getOrDefault(curKey, new HashSet<>())) {
                indegree.put(nextKey, indegree.get(nextKey) - 1);
                if (indegree.get(nextKey) == 0) queue.add(nextKey);
            }
        }
        return dict;
    }

    public static String replaceWord(String input, HashMap<String, String> map) {
        HashMap<String, String> finalDict = replaceHelp(map);
        return replace(input, finalDict);
    }

    public static void main(String[] args) {
        HashMap<String, String> map = new HashMap<>();
        map.put("USER", "admin");
        map.put("HOME", "/%USER%/home");
        String input = " I am %USER% My home is %HOME%";
        System.out.println(replaceWord(input, map));
    }
}
--







-------------------------------------------------------------------------------------



Q6-

You are given a list of user sessions where each user session has start and end times both inclusive. Now, given a value N, find the count of all users at each point in time from [0,N) i.e include 0 but exclude N. Example:
Input:
[(0,3), (1,4) ] N=7
Output:
0->1
1->2
2->2
3->2
4->1





Q-6
import java.util.Arrays;

public class Test {
    public static void countUser(int[][] session, int n) {
        int[] count = new int[n];
        Arrays.fill(count, 0);
        for (int[] se : session) {
            int s = se[0];
            int e = se[1];
            count[s] += 1;
            if (e + 1 < n) {
                count[e + 1] -= 1;
            }
        }
        for (int i = 1; i < n; i++) {
            count[i] += count[i - 1];
        }

        for (int i = 0; i < n; i++) {
            System.out.println(i + " -> " + count[i]);
        }
    }

    public static void main(String[] args) {
        int[][] session = {{0, 3}, {1, 4}};
        countUser (session, 7);
    }
}


----------------------------------------


A number of students are taking exams in a room. Students sitting adjacent to each other and taking the same exam can cheat. Arrange the students so that cheating opportunities are minimized. I was free to choose input format.
I chose the input to be a list of length n, denoting n students. The element at index i would indicate the exam student i is taking.
For example, [1,2,3,1,2,2]
Student 0 is taking exam 1
Student 1 is taking exam 2
Student 2 is taking exam 3
Student 3 is taking exam 1
Student 4 is taking exam 2
Student 5 is taking exam 2
Output would be a list with the students re-arranged. An acceptable output for the above case would be [1,2,3,2,1,2].




Q-7
int32_t main() {
    ios::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);
    
    vector<int>A = { 2 , 2 , 2 , 2 , 1 , 1 } ;
    
    unordered_map< int , int > mp ;
    for( auto x : A )
    {
        mp[x]++;
    }
    priority_queue< ar > pq ; // freq , id 

    vector< int > res ;

    for( auto x : mp )
    {
        int a = x.first ;
        int b = x.second ;
        pq.push({ b , a });
    }

    // { 4 , 2 } { 2 , 1 }

    while(pq.size() > 1 )
    {
       auto beg = pq.top(); pq.pop(); // this is most frequent 
       // we will use it to interleave numbers 

       while( pq.size() && beg[0] > 0 )
       {
          auto next = pq.top(); pq.pop();

          res.push_back(beg[1]);
          res.push_back(next[1]);

          beg[0]--; // used it 
          next[0]--; // used it 

          if( next[0] > 0 )
            pq.push({ next });
       }

       if( beg[0] > 0 )
        pq.push(beg);
    }
        
    auto cnt = pq.top()[0];
    int id = pq.top()[1];

    while(cnt--)
        res.push_back(id);

    for( auto x : res )
        cout<<x<<" ";
    cout<<endl;

return 0;
}   

//TC : O(N⋅logk) and SC : O(K)









---------------------------------------------------------------


Q8-

Replace files with directories if all files in directory are
specified
Example input & output:
allFiles = [
"a/b/c/d.txt",
"a/b/c/e.txt",
"a/b/b.txt",
"a/b/e.txt",
"b/c/d.txt"
]
subsetFiles = [
"a/b/c/d.txt",
"a/b/c/e.txt",
"a/b/b.txt",
"b/c/d.txt"
]
output=[
"a/b/c",
"a/b/b.txt",
"b"
]



Q-8
class TrieNode {
    Map<String, TrieNode> children;
    boolean isFile;
    int childrenCount;

    TrieNode() {
        children = new HashMap<>();
        isFile = false;
        childrenCount = 0;
    }
}

class Trie {
    TrieNode root;

    Trie() {
        root = new TrieNode();
    }

    public void insert(String[] words) {
        TrieNode ws = root;

        for (String word : words) {
            ws.childrenCount += 1;
            if (!ws.children.containsKey(word)) {
                ws.children.put(word, new TrieNode());
            }
            ws = ws.children.get(word);
        }
        ws.isFile = true;
    }

    public void decrementChildren(String[] words) {
        TrieNode ws = root;

        for (String word : words) {
            if (!ws.children.containsKey(word)) {
                return;
            }
            ws.childrenCount -= 1;
            ws = ws.children.get(word);
        }
    }

    public void search(String[] words) {
        TrieNode ws = root;

        for (String word : words) {
            if (!ws.children.containsKey(word)) {
                return;
            }
            ws = ws.children.get(word);
            System.out.println(word + ":" + ws.childrenCount);
        }
    }

    public String getPath(String[] words) {
        TrieNode ws = root;
        StringBuilder sb = new StringBuilder();
        for (String word : words) {
            ws = ws.children.get(word);
            if (ws.childrenCount == 0 || ws.isFile) {
                sb.append(word);
                return sb.toString();
            }
            sb.append(word + "/");
        }

        return new String();
    }
}

public class Main {
    public static List compressInput(List all_files, List selected_files) {
        Trie trie = new Trie();

        for (String filePath : all_files) {
            String[] words = filePath.split("/");
            trie.insert(words);
        }

        for (String filePath : all_files) {
            String[] words = filePath.split("/");
            trie.search(words);
        }

        for (String filePath : selected_files) {
            String[] words = filePath.split("/");
            trie.decrementChildren(words);
        }

        for (String filePath : selected_files) {
            String[] words = filePath.split("/");
            trie.search(words);
        }

        List<String> result = new ArrayList<>();

        for (String filePath : selected_files) {
            String[] words = filePath.split("/");
            String finalPath = trie.getPath(words);
            if (finalPath.length() != 0 && !result.contains(finalPath))
                result.add(finalPath);
        }

        return result;
    }

    public static void main(String[] args) {
        List<String> all_files = Arrays.asList("a/b.txt", "b/c.txt", "b/d.txt", "c/e.txt", "c/f/a.txt", "c/f/b.txt", "c/g.txt", "d/a/b.txt");

        List<String> selected_files = Arrays.asList("b/c.txt", "b/d.txt", "c/e.txt", "c/f/a.txt", "c/f/b.txt", "d/a/b.txt");

        System.out.println(compressInput(all_files, selected_files));
    }
}




-----------------------------------------------------------------


Q9-

You have a stream of rpc requests coming in. Each log is of the
form {id, timestamp, type(start/end)}. Given a timeout T, you need to figure out at the earliest possible time if a request
has timed out.
Eg :
id - time - type
0 - 0 - Start
1 - 1 - Start
0 - 2 - End
2 - 6 - Start
1 - 7 - End
Timeout = 3
Ans : {1, 6} ( figured out id 1 had timed out at time 6 )


Q-9
public class Main {
    public static void main(String[] args) {
        Log[] logs = new Log[] {
                new Log(0, "start", 0),
                new Log(1, "start", 1),
                new Log(0, "end", 2),
                new Log(2, "start", 6),
                new Log(1, "end", 7),
        };

        /* Log[] logs = new Log[] {
            new Log(0, "start", 0),
            new Log(1, "start", 1),
            new Log(0, "end", 5),
            new Log(1, "end", 2),
        }; */

        RequestTimeOut  re = new RequestTimeOut();
        int[] ans = re.firstExpiredEarliestLog(logs, 3);
        System.out.println(Arrays.toString(ans));
    }
}
class Log {
    int id;
    String type;
    int time;
    public Log(int _id, String _type, int _time) {
        type = _type;
        time = _time;
        id = _id;
    }
}
class RequestTimeOut {
    Queue<Log> queue;
    Set<Integer> logIdSet;
    public RequestTimeOut(){
        queue = new LinkedList();
        logIdSet = new HashSet();
    };
    public int[] firstExpiredEarliestLog(Log[] logs, int timeout){
        // code goes here
        for(Log log: logs) {

            while(!queue.isEmpty() && (queue.peek().time + timeout) < log.time) {
                Log firstLog = queue.remove();
                if(!logIdSet.contains(firstLog.id)) {
                    return new int[]{ firstLog.id, log.time };
                }
            };

            if(log.type.equals("end")) {
                logIdSet.add(log.id);
            } else {
                queue.add(log);
            }

        };
        return new int[]{};
    }
}


--------------------------------------------------------------


Give a list of string, where every string in the list is of size 5. Return the list of 5 string such that all the characters in each of the strings are unique
i.e if we combine all the strings(not nnecessary) we will have 25 unique characters)
eg
Input explanation
List of string with length of 5 each
intput = ["abcde", "fghij", "klmno", "pqrst", "uvwxy", "zabcd", "apple", "zebra", "ocean", "quick", "world", "jumps", "foxes", "liver"]





Q-10
public List<String> solution(String[] strs) {
    return dfs(0, 0, strs, new HashSet<>());
}

private List<String> dfs(int i, int curWordsCount, String[] strs, Set<Character> charsUsed) {
    if (curWordsCount == 5)
        return new ArrayList<>();
    if (i == strs.length)
        return null;

    List<String> result = dfs(i + 1, curWordsCount, strs, charsUsed);
    if (result != null)
        return result;

    if (canAdd(i, strs, charsUsed)) {
        for (char c : strs[i].toCharArray())
            charsUsed.add(c);

        result = dfs(i + 1, curWordsCount + 1, strs, charsUsed);
        if (result != null) {
            result.add(strs[i]);
            return result;
        }
        for (char c : strs[i].toCharArray())
            charsUsed.remove(c);
    }

    return null;
}

private boolean canAdd(int i, String[] strs, Set<Character> charsUsed) {
    for (char c : strs[i].toCharArray()) {
        if (charsUsed.contains(c))
            return false;
    }
    return true;
}


--------------------------------------------


Q11-

sort all odd elements and leave even elements as it is at their original position | [ x-> 2*x+1 -> sort() -> (x-1)/2 ; ]




Q-11
// Java program for the above approach
import java.util.*;

public class GFG {

    // Function to get the required array
    static void solve(int []arr, int n)
    {

        // Store even elements
        ArrayList<Integer> evens = new ArrayList<Integer>();
        for (int i = 0; i < n; i++) {
            if (arr[i] % 2 == 0)
                evens.add(arr[i]);
        }

        // Sort all even elements
        Collections.sort(evens);

        int l = 0;

        // Placing even elements in sorted order
        for (int i = 0; i < n; i++) {
            if (arr[i] % 2 == 0)
                arr[i] = evens.get(l++);
        }

        // Updated array
        for (int i = 0; i < n; i++)
            System.out.print(arr[i] + " ");
    }

    // Driver function
    public static void main(String []args)
    {
        int N = 5;
        int []arr = { 4, 7, 2, 11, 15 };
        solve(arr, N);

    }
}



--------------------------------------------------------------

Q12-

You work as a consultant and have clients in cityA and cityB. On a given day,
say i, you can either
work in cityA and make Ai dollars or you can work in cityB and make Bi dollars. You can also spend
the day traveling between cityA and cityB in which case your earnings that day are 0.
Given Al,A2, ....An and B1, B2,....., Bn, return a schedule S of N days which maximizes your earnings,
where S is a string of length N, and Si = A/B/T where A means work in cityA, B means work in cityB
T means travel on day i. You can start either in cityA or cityB. Example1: A = [23, 4,5 ,101] B = [21,1,10, 100] The optimal schedule S here would be ->"ATBB"
Example 2:
A[25,10,15,10,70] B = [5,5,50,5,30] The optimal schedule S here would be-> "ATBTA"




Q-12
public class Test {
    public static void main(String[] args) {
        int[] A = {23, 4, 5, 20};
        int[] B = {21, 1, 10, 100};
        System.out.println(maxProfitSchedule(A, B));
    }

    public static String maxProfitSchedule(int[] A, int[] B) {
        int days = A.length;

        // dp[day][city], 0 is A and 1 is B
        int[][] dp = new int[days + 1][2]; // 5,2

        for (int day = days - 1; day >= 0; day--) {
            dp[day][0] = Math.max(A[day] + dp[day + 1][0], dp[day + 1][1]); // day 3 [20+0,0],day 2[5+20,100]
            dp[day][1] = Math.max(B[day] + dp[day + 1][1], dp[day + 1][0]); //day 3[100+0,0],day 2[10+100,20]
        }
        //at the end dp[0] --133,132,dp[1]--110,111,dp[2]-100,110,dp[3]-20,100,dp[4]-0,0
        // Construct the result
        StringBuilder sb = new StringBuilder();
        int currentCity = (dp[0][0] > dp[0][1]) ? 0 : 1; //0

        for (int day = 0; day < days; day++) {
            if (currentCity == 0) {
                if (A[day] + dp[day + 1][0] > dp[day + 1][1]) { //133>111
                    sb.append('A');
                } else {
                    sb.append('T');
                    currentCity = 1;
                }
            } else {
                if (B[day] + dp[day + 1][1] > dp[day + 1][0]) {
                    sb.append('B');
                } else {
                    sb.append('T');
                    currentCity = 0;
                }
            }
        }

        return sb.toString();
    }
}


---------------------------------------------------------------------------------------





Q13-

Give the count of managers who has salary less than average salary of direct and indirect employees
Example:
A->B, A->C, A->D, B->E
Salaries
A = 50000
B = 20000
C = 10000
D = 10000
E = 25000
Answer: 1


Explanation: A is the manager of direct employees B, C, D and indirect employee E so avg. is 16,250 and B = 20000 < E = 25000 so answer is B




Q-13
public class Main {
    public static void main(String[] args) {
        Main main = new Main();
        main.question1();
    }

    Map<Character, Set<Character>> map;
    Map<Character, Integer> salaryMap;
    List<Character> resultChar;
    List<Integer> resultNum;

    private void initMap() {
        map = new HashMap<>();
        map.put('A', new HashSet<>());
        map.put('B', new HashSet<>());
        map.get('A').add('B');
        map.get('A').add('C');
        map.get('A').add('D');
        map.get('B').add('E');

        salaryMap = Map.of(
                'A', 50000,
                'B', 20000,
                'C', 10000,
                'D', 10000,
                'E', 25000
        );
        resultChar = new ArrayList<>();
        resultNum = new ArrayList<>();
    }
    private void question1() {
        initMap();
        dfs('A');
        System.out.println(resultChar.toString());
        System.out.println(resultNum.toString());
    }

    private int[] dfs(char curr) {
        int totalChildren = 0;
        int totalSalary = 0;
        if (map.containsKey(curr)) {
            for (Character i : map.get(curr)) {
                int[] val = dfs(i);
                totalChildren += val[0];
                totalSalary += val[1];
            }
            if (((totalSalary * 1d) / (totalChildren * 1d)) > salaryMap.get(curr) * 1d) {
                resultChar.add(curr);
                resultNum.add(salaryMap.get(curr));
            }
        }
        return new int[] {totalChildren + 1, totalSalary + salaryMap.get(curr)};
    }
}





-------------------------------------------------------------------------


Q14-

There is a robot at location (0, 0) of a 10x10 grid of tiles. Each tile can be one of 8 different colors: (0, 1, ... 7). There is a star at a known location (marked with the color -1) on the grid. You can program the robot by giving it a lookup table of color to direction. The robot will sense the color of the tile it is currently on, and move in the direction (up, down, left, or right) specified by the lookup table you provided. Output a lookup table that guides the robot to the star, if such a table is possible.
Small example grid: [[(0), 1, 0, 0], [3, 2,-1, 3], [0, 0, 0, 2], [0, 0, 0, 4]]



Q-14
package org.example;

import java.util.*;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import java.util.HashMap;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;

public class Test {
    private static Map<Integer, int[]> getLookupTable(int[][] grid) {
        int rows = grid.length;
        int columns = grid[0].length;
        int[][] directions = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};
        Map<Integer, int[]> lookupTable = new HashMap<>();
        Set<String> visited = new HashSet<>();

        class DFS {
            public boolean dfs(int row, int column) {
                if (row < 0 || row >= rows || column < 0 || column >= columns) {
                    return false;
                }
                int color = grid[row][column];
                if (color == -1) {
                    return true;
                }
                if (lookupTable.containsKey(color)) {
                    int[] direction = lookupTable.get(color);
                    int nextRow = row + direction[0];
                    int nextCol = column + direction[1];
                    String nextPos = nextRow + "," + nextCol;
                    if (!visited.contains(nextPos)) {
                        visited.add(nextPos);
                        if (dfs(nextRow, nextCol)) {
                            return true;
                        }
                        visited.remove(nextPos);
                    }
                } else {
                    for (int[] direction : directions) {
                        lookupTable.put(color, direction);
                        if (dfs(row, column)) {
                            return true;
                        }
                        lookupTable.remove(color);
                    }
                }
                return false;
            }
        }
        DFS dfs = new DFS();
        if (dfs.dfs(0, 0)) {
            return lookupTable;
        }
        return null;
    }

    public static void main(String[] args) {
        int[][] grid = {
                {0, 1, 0, 0},
                {3, 2, -1, 3},
                {0, 0, 0, 2},
                {0, 0, 0, 4}
        };
        Map<Integer, int[]> lookupTable = getLookupTable(grid);
        if (lookupTable != null) {
            for (Map.Entry<Integer, int[]> entry : lookupTable.entrySet()) {
                System.out.println("Color: " + entry.getKey() + ", Direction: (" + entry.getValue()[0] + ", " + entry.getValue()[1] + ")");
            }
        } else {
            System.out.println("No lookup table found.");
        }
    }
}











------------------------------------------------------------




There is a stream of integers. Every time you see a new element in the stream, return the mean value of the last N elements, excluding the largest K elements.
Example:
N=5
K=2
elements so far = [20, 2, -2, 0, 10, 1, 5, -2, 0]
last N elements: [10, 1, 5, -2, 0] largest K elements: [10, 5]
result = (1+(-2)+0)/3 = -0.3333333




Q-15
package org.example;

import java.util.*;

public class Test {
    public static void main(String[] args) {
        TreeSet<Integer> bottom = new TreeSet<>();
        //bottom contains the N-K elements we want and top the top k elements

        TreeSet<Integer> top = new TreeSet<>(Collections.reverseOrder());

        int N = 5;
        int K = 2;
        ArrayList<Integer> S = new ArrayList<Integer>() {{
            add(20); add(4); add(2); add(1); add(-2); add(20); add(0); add(10);
            add(4); add(1); add(19); add(14); add(11); add(8); add(25); add(1);
        }};
        double sum = 0;
        for(int i = 0; i < S.size(); i++) {
            if(bottom.size() < N - K) {
                bottom.add(S.get(i));
                sum += S.get(i);
            } else {
                //we have read N elements, so we need to remove from either bottom or top the element in position S[i-N]

                if(i >= N) {
                    if(top.contains(S.get(i - N))) {
                        top.remove(S.get(i - N));
                    } else {
                        //it must be in bottom
                        sum -= S.get(i - N);
                        bottom.remove(S.get(i - N));

                        //bring minimum of top to bottom
                        int firstTop = top.first();
                        sum += firstTop;
                        bottom.add(firstTop);
                        top.remove(firstTop);
                    }
                }
                //now process the next element
                int bottomMaxValue = bottom.last();
                if (S.get(i) > bottomMaxValue) {
                    top.add(S.get(i));
                } else {
                    top.add(bottomMaxValue);
                    bottom.remove(bottomMaxValue);
                    bottom.add(S.get(i));
                    sum += (S.get(i) - bottomMaxValue);
                }
                if(i >= N - 1) {
                    System.out.print("Found new mean: " + sum / (N - K) + " from elements ");
                    Iterator<Integer> it = bottom.iterator();
                    while(it.hasNext()) {
                        System.out.print(it.next() + " ");
                    }
                    System.out.println();
                }
            }
        }
    }
}







-------------------------------------------------------------------------------


Q16-

Find the length of longest increasing subsequence such that the difference between consecutive elements in LIS is an increasing sequence
Example :
nums -> 1 2 3 4 5 6 ans -> 3
Explanation : the best LIS can be gotten if we take 1 , 2 , 4 ( in this way )



Q-16
import java.util.Arrays;
import java.util.HashMap;
import java.util.Map;

public class Main {
    private static int[][] A;
    private static Map<String, Integer> memo = new HashMap<>();

    public static void main(String[] args) {
        int[] nums = {1, 2, 4, 5, 7, 1, 5, 2, 6, 4, 1, 19};
        A = new int[nums.length][2];
        for (int i = 0; i < nums.length; i++) {
            A[i] = new int[]{nums[i], i};
        }
        Arrays.sort(A, (a, b) -> a[0] - b[0]);
        int res = 0;
        for (int a = 0; a < A.length; a++) {
            for (int b = a + 1; b < A.length; b++) {
                res = Math.max(res, 1 + dp(a, b));
            }
        }
        System.out.println(res);
    }

    private static int dp(int pre, int cur) {
        if (cur >= A.length) {
            return 0;
        }
        String key = pre + "," + cur;
        if (memo.containsKey(key)) {
            return memo.get(key);
        }
        int res = dp(pre, cur + 1);
        if (A[cur][1] > A[pre][1]) {
            int dif = A[cur][0] - A[pre][0];
            int newIdx = findNewIndex(dif + A[cur][0] + 1);
            if (newIdx > cur) {
                res = Math.max(res, 1 + dp(cur, newIdx));
            }
        }
        memo.put(key, res);
        return res;
    }

    private static int findNewIndex(int value) {
        int low = 0;
        int high = A.length - 1;
        while (low <= high) {
            int mid = (low + high) >>> 1;
            if (A[mid][0] < value) {
                low = mid + 1;
            } else if (A[mid][0] > value) {
                high = mid - 1;
            } else {
                return mid;
            }
        }
        return low;
    }
}





---------------------------------------------------------------------------------------------

Q-17
Given a series of stones with certain values, whenever you jump on to any stone ,number of points you would earn will be length you have jumped times the value of that stone.
Assume you have reached to the last stone, what would be the maximum score earned
Example : [3,7,10,12,8,10]
for 3 - score 0
for 3,7 - max score till 7 is 7
for 3,7,10 - max score would be max(10x2, 7+10)- 20
for 3,7,10,12 - max score max(12x3,12+20,12x2+7) - 36
n so on
public static void main(String[]args){
        int[]arr={10,8,6,5,4,3};

        int[]ans=solve(arr);

        for(int i=0;i<arr.length;i++)
        System.out.print(ans[i]+", ");   // answer
        }
static int[]solve(int[]nums){
        int n=nums.length;
        int[]dp=new int[n];

        dp[0]=0;
        dp[1]=nums[1];

        for(int i=2;i<n; i++){
        int j=binarySearch(0,i-1,i,nums,dp);

        if(j==i)dp[i]=nums[i]*i;      // take a jump from 0th stone 
        else{
        dp[i]=dp[j]+(nums[i]*(i-j));    // jump to 'jth' stone first & then jump to ith stone
        }
        }
        return dp;
        }

static int binarySearch(int s,int e,int i,int[]nums,int[]dp){
        while(s<=e){
        int mid=(s+e)/2;   // index from where we are going to jump

        int m1=dp[mid]+(nums[i]*(i-mid));     // score when jumped from mid'th stone
        int m2=dp[mid+1];          //score when jumped from mid + 1'th stone

        if(mid+1==i)m2+=(nums[i]*i);      // if mid + 1 stone == ith stone
        else m2+=(nums[i]*(i-(mid+1)));

        if(m1<m2)s=mid+1;
        else e=mid-1;
        }
        return s;   // jump from the s'th stone is decided at last
        }
---




For Q 18: I got this question in one the Google onsites and solved it in
Time Complexity: O(n) and Space Complexity :O(1)

The optimal approach is to move greedily with the following strategy

From a particular index you would always want to jump to the next greatest stone
Intuition : Whenever you land on a stone you multiply the jumps* value of that stone so jumping on the next greatest stone makes it optimal

Code :

int getMaxScore(vector<int>& stones){
     int max_score = 0;
     int n = stones.size();
     int next_greatest = stones[n-1];
     for(int i=n-1;i>0;i--){
         next_greatest = max(next_greatest, stones[i]);
         max_score += next_greatest;
     } 
    return max_score;
}


int32_t main() {
    ios::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);
    
        vector<int>A = { 3,7,10,12,8,10 };
        int N = A.size();
        vector<int>L(N,0);
        stack<int>st ;

        for( int i = 0 ; i < N ; i++ )
        {
            while( st.size() && A[i] >= A[st.top()] )st.pop();

            if( st.size() == 0 )
                L[i] = 0 ;
            else
                L[i] = st.top();

            st.push(i);
        }

        vector<int>dp(N,0);

        for( int i = 1 ; i < N ; i++ )
        {
            int k = L[i];
            int cost = A[i] * abs( i - k );

            dp[i] = dp[k] + cost ;
        }

        cout<<dp.back()<<endl;
    
return 0;
}   


-----------------------------------------------------------------------------

Q17-


Given a sparse bit array A of size M stored in a database. The database provides an API query(L,R) which returns 1 if there is at least one bit equal to one in A[L..R] and 0 otherwise.

You want to find all the 1 bits in a reasonable number of queries. E.g. for array 01100000001, positions of 1 bits are {1, 2, 10}.

Return the array of all the positions of 1's.

T.C -> It should not be linear.
S.C -> It should be constant.

You should not use recursion or extra function. (this part was the followup to the recursive and queue approach).







FULL LIST: https://leetcode.com/discuss/interview-question/3851271/Google-Coding-Interview-Questions







: https://leetcode.com/problems/accounts-merge/description/

https://leetcode.com/problems/smallest-sufficient-team/description/

https://leetcode.com/discuss/interview-question/4669794/Google-India-(New-grad)-or-Onsite-or-Merge-intervals-based-on-importance

https://leetcode.com/problems/find-all-people-with-secret/description/


https://leetcode.com/discuss/interview-question/3898065/Google-Phone-Screen-or-Aug-2023






I have been contacted by the recruiter through linkedin and the process took 2 months. Listing more below:

Coding Round 1: DP problem (Maximum path sum in matrix)

Coding Round 2: Topology Sort of recipes (https://leetcode.com/problems/find-all-possible-recipes-from-given-supplies/description/)

Coding Round 3: Binary Search, find bad commit (https://leetcode.com/discuss/interview-question/1831538/Google-or-Phone-Interview-or-SDE-1-or-Find-bad-commit)



Behavioural Round: STAR based questions (like):
Have you ever had a conflict with your team-member. How did you handle the situation.
Have you ever handled a difficult situation/task. Tell me more about it.
System Design Round: Design aggregation ratings and comments system at YouTube scale.
System Design Round: How to design Google Chrome Update System.

Did well in the coding rounds and behavioural. But did not do well in HLD and got rejected. Hope this experience would be of some help to someone.





Coding Question:

You are working on a project and you noticed that there has been a performance decrease between two releases. You have a function:

boolean worseCommit(int commit1, int commit2)
that runs performance tests and returns true if commit2 is worse than commit1 and false otherwise.

Find all of the bad commits that have decreased the performance between releases. Assume no improvement in performance.

Commit Id: 1, 2, 3, 4, 5, 6, 7, 8, 9

Performance: 10, 10, 10, 8, 8, 8, 5, 5, 5

Output 4, 7

this problem is same as : first bad version 















Education : Tier-2, CS
YOE : 1.5
Experience : SWE, Product Company; Current TC : 25L
Company: Google, India
Title/Level: SWE-2, L3
Location: Bangalore
Salary: 23,84,000
Sign-on Bonus : 3,60,000
Stock : 55K USD, front loaded, ~17,38,445 for first year
Bonus: 3,28,500
Benefits: Standard Google Perks

Total TC : Year-1 : ~48L

Didn't have competing offers, would be accepting this.




TRIE: question: format of printing linus directory