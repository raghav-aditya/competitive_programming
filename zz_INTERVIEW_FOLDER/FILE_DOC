public static void main(String[] args) {               
List<String> l1 = new ArrayList<>();                
l1.add("1");                
List<String> l2 = new ArrayList<>();                
l2.add("2");                
updateL1WithL2(l1, l2);                
System.out.println(l1);  // 1       
}        
 
static void updateL1WithL2(List<String>  l1, List<String>  l2) 
{   l1 = l2;             
l1.add("1");           
l1.add("3");        
}
}



----


----

// L1 = 2, 1,3  
// L2 = 2 





---------------------------------

class SharedCounter {
    private int counter = 0;
    public void increment() {
        counter++;
    }
    public int getCounter() {
        return counter;
    }
}
 
public class Test {
    public static void main(String[] args) {
        SharedCounter sharedCounter = new SharedCounter();
        Thread thread1 = new Thread(() -> {
            for (int i = 0; i < 5; i++) {
                sharedCounter.increment();
            }
        }, "Thread-1");
        Thread thread2 = new Thread(() -> {
            for (int i = 0; i < 5; i++) {
                sharedCounter.increment();
            }
        }, "Thread-2");
        thread1.start();
        thread2.start();



        Systen.out.println(sharedCounter.getCounter()) // 0 - 10 
    }
}


---------------------------------------



Given two integers arrays A and B of size N each.
 
 
Find the maximum N elements from the sum combinations (Ai + Bj) formed from elements in array A and B.



// first brute forces -> generate all candidates -> sorting / priority -> max N elemetns 

	1. N^2 * 2 * log( N )
	2. N*^2 * log(N) 



-----------------------------------

	 // are we A[i] >= 0 , B[i] >= 0 ;

	 // A -> [ - ]  | [ + ]
	 // B -> [ - ]  | [ + ]

	 A1 ( negative ) -> [ ] 
	 A2 ( positive ) -> [ ]

	 B1 ( negative ) -> []
	 B2 ( positive ) -> [ ]

	 						 i

	 A2 -> [ 1 , 2 , 3 , 4 , 5 ]
	 B2 -> [ 3 , 4 , 11 , 22 ]
	 						j

	 priority_queue< { value , i , j } > pq // max heap 

	 int k = N ;
	 
	 vector< int > candidates ; // // 2*N -> N 

	 while( pq.size() && k-- )
	 {
	 	auto beg = pq.top() ; pq.pop();

	 	int val = beg[0];
	 	int i = beg[1];
	 	int j = beg[2];

	 	candidates.push_back(val);


	 	if(i-1>=0)
	 	pq.push({ A[i-1]*A[j] , i-1 , j });
	 	
	 	if(j-1>=0)
	 	pq.push({ A[i]*A[j-1] , i , j-1 });

	 	pq.size() > 3 
	 }





-----------------------------

	
	graphs -> 
	weight -> 0 / 1  -> [ 00000000000011111111111   ] 

	shortest path from a node to all 

	// 
	deque -> [ ]


// disticnt elements 
// random order 
// min no of swaps -> 
// N*logN ( )
// 

	A -> [ 32 ,  2  , 91 ]
	A -> [ 1 , 0 , 2 ]	// { 1 , N } 


int f( vector<int>&A )
{
	int N = A.size();

	int res= 0 ;

	for( int i = 0 ; i < N ; i++ )
	{
		int v = A[i];
		int cp = i ;
		int ap = v ;

		if( cp != ap )
		{
		   swap( A[cp] , A[ap] );
		   res++;
		   i--;  // this part crucial 
		}
	}


	return res ;
}




	




